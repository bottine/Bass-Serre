import category_theory.path_category
import category_theory.quotient
import category_theory.groupoid
import algebra.group.defs
import algebra.hom.group
import algebra.hom.equiv 
import data.set.lattice
import combinatorics.quiver.connected_component

/-
path_category == the free category of pats
quotient == quotienting morphisms by relations
algebra.hom.equiv to use ‚âÉ*
-/

open set

namespace category_theory

universes u v 

variables {C : Type u} 

instance groupoid.vertex_group [groupoid C] (c : C): group (c ‚ü∂ c) :=
{ mul := Œª (x y : c ‚ü∂ c), x ‚â´ y
, mul_assoc := category.assoc --Œª (x y z : c ‚ü∂ c), by simp only [category.assoc]
, one := ùüô c
, one_mul := category.id_comp
, mul_one := category.comp_id
, inv := groupoid.inv
, mul_left_inv := groupoid.inv_comp }

@[simp] lemma groupoid.vertex_group.mul_eq_comp [groupoid C] (c : C) (Œ≥ Œ¥ : c ‚ü∂ c) : Œ≥ * Œ¥ = Œ≥ ‚â´ Œ¥ := rfl

def groupoid.vertex_group_isom_of_map [groupoid C] {c d : C} (f : c ‚ü∂ d) : 
  (c ‚ü∂ c) ‚âÉ* (d ‚ü∂ d) := 
begin
  refine_struct ‚ü®Œª Œ≥, (groupoid.inv f) ‚â´ Œ≥ ‚â´ f, Œª Œ¥, f ‚â´ Œ¥ ‚â´ (groupoid.inv f), _, _, _‚ü©,
  { rintro x,
    simp_rw [category.assoc, groupoid.comp_inv, category.comp_id,‚Üêcategory.assoc, groupoid.comp_inv, category.id_comp], },
  { rintro x,
    simp_rw [category.assoc, groupoid.inv_comp, ‚Üêcategory.assoc, groupoid.inv_comp,category.id_comp, category.comp_id], },
  { rintro x y,
    have : x ‚â´ y = x ‚â´ f ‚â´ (groupoid.inv f) ‚â´ y, by 
    { congr, rw [‚Üêcategory.assoc,groupoid.comp_inv,category.id_comp], },
    simp [this,groupoid.vertex_group.mul_eq_comp,category.assoc], },
end


def groupoid.vertex_group_isom_of_path [groupoid C] (c d : C)  (p : quiver.path c d) : (c ‚ü∂ c) ‚âÉ* (d ‚ü∂ d) :=
begin
  induction p,
  { reflexivity },
  { apply p_ih.trans,  apply groupoid.vertex_group_isom_of_map, assumption, }
end


section
open quiver
instance [G : groupoid C] : has_reverse C := ‚ü®Œª a b, G.inv‚ü©
end

namespace groupoid

section subgroupoid

variable (G : groupoid C)

@[ext]
structure subgroupoid :=
  (arrws : ‚àÄ (c d : C), set (G.hom c d))
  (inv' : ‚àÄ {c d} {p : G.hom c d} (hp : p ‚àà arrws c d), 
            groupoid.inv p ‚àà arrws d c)
  (mul' : ‚àÄ {c d e} {p} (hp : p ‚àà arrws c d) {q} (hq : q ‚àà arrws d e), 
            p ‚â´ q ‚àà arrws c e)

--instance: has_coe_to_fun (subgroupoid G) (Œª S, Œ† (c d : C), set (G.hom c d)) := ‚ü®Œª S, S.arrws‚ü©

variable {G}

lemma subgroupoid.nonempty_isotropy_to_mem_id (S :subgroupoid G) (c : C) : 
  (S.arrws c c).nonempty ‚Üí ùüô c ‚àà S.arrws c c :=
begin
  rintro ‚ü®Œ≥,hŒ≥‚ü©,
  have : ùüô c = Œ≥ * (G.inv Œ≥), by simp only [vertex_group.mul_eq_comp, comp_inv],
  rw this, apply S.mul', exact hŒ≥, apply S.inv', exact hŒ≥,
end

def subgroupoid.carrier (S :subgroupoid G) : set C := {c : C | (S.arrws c c).nonempty }

def subgroupoid.coe_quiver (S : subgroupoid G) : quiver (S.carrier) := ‚ü®Œª a b, S.arrws a b‚ü©

def subgroupoid.coe_category_struct  (S : subgroupoid G) : category_struct (S.carrier) :=
begin
  haveI := S.coe_quiver,
  constructor,
  { rintro ‚ü®a,ha‚ü©, sorry,},
  { rintro ‚ü®a,ha‚ü© ‚ü®b,hb‚ü© ‚ü®c,hc‚ü© p q, sorry }
end

-- this is probably not going anywhere‚Ä¶

def is_subgroupoid (S T : subgroupoid G) : Prop :=
  ‚àÄ {c d}, S.arrws c d ‚äÜ T.arrws c d

instance subgroupoid_le : has_le (subgroupoid G) := ‚ü®is_subgroupoid‚ü©

def le_refl (S : subgroupoid G) : S ‚â§ S :=
by {rintro c d p, exact id,}

def le_trans (R S T : subgroupoid G) : R ‚â§ S ‚Üí S ‚â§ T ‚Üí R ‚â§ T :=
by {rintro RS ST c d, exact (@RS c d).trans (@ST c d), } 

def le_antisymm (R S : subgroupoid G) : R ‚â§ S ‚Üí S ‚â§ R ‚Üí R = S :=
by {rintro RS SR, ext c d p, exact ‚ü®(@RS c d p), (@SR c d p)‚ü©,}


instance : partial_order (subgroupoid G) := 
{ le := is_subgroupoid,
  le_refl := le_refl,
  le_trans := le_trans,
  le_antisymm := le_antisymm}

instance : has_top (subgroupoid G) := ‚ü®‚ü®(Œª _ _, set.univ), by {rintros,trivial,}, by {rintros, trivial,}‚ü©‚ü©
instance : has_bot (subgroupoid G) := ‚ü®‚ü®(Œª _ _, ‚àÖ), by {rintros, simpa using hp,}, by {rintros, simpa using hp,}‚ü©‚ü©

def le_top (S : subgroupoid G) : S ‚â§ ‚ä§  := 
begin
  dsimp only [has_top.top], 
  rintros c d,
  simp [subset_univ], 
end

def bot_le (S : subgroupoid G) : ‚ä•   ‚â§ S :=
begin
  dsimp only [has_bot.bot],
  rintros c d,
  simp only [empty_subset, implies_true_iff],
end


instance : has_inf (subgroupoid G) := 
‚ü® Œª S T, 
  ‚ü®(Œª c d, (S.arrws c d)‚à©(T.arrws c d))
  , by {rintros, exact ‚ü®S.inv' hp.1,T.inv' hp.2‚ü©}
  , by {rintros, exact ‚ü®S.mul' hp.1 hq.1, T.mul' hp.2 hq.2‚ü©}‚ü©‚ü©


lemma le_inf {R S T : subgroupoid G} : R ‚â§ S ‚Üí R ‚â§ T ‚Üí R ‚â§ S ‚äì T :=
begin
  rintros RS RT,
  rintros c d p pR, exact ‚ü®RS pR, RT pR‚ü©,
end

instance : has_Inf (subgroupoid G) :=
‚ü® Œª s,
  ‚ü®(Œª c d, set.Inter (Œª (S : s), S.val.arrws c d))
  , by {rintros, rw set.mem_Inter, rintro S, apply S.val.inv', apply hp, simp, use [S.val, S.prop], refl,}
  , by {rintros, rw set.mem_Inter, rintro S, apply S.val.mul', apply hp, use [S.val,S.prop], apply hq, use [S.val,S.prop],}‚ü©‚ü©




instance : complete_lattice (subgroupoid G) :=
{ bot          := (‚ä•),
  bot_le       := sorry,
  top          := (‚ä§),
  le_top       := sorry,
  inf          := (‚äì),
  le_inf       := sorry,
  inf_le_left  := sorry,
  inf_le_right := sorry,
  .. complete_lattice_of_Inf (subgroupoid G) sorry }

def discrete [decidable_eq C] : subgroupoid G := 
‚ü® Œª c d, if h : c = d then {h.rec_on (G.id c)} else ‚àÖ
, by 
  { rintros c d p hp, 
    by_cases h : d = c, 
    { subst_vars, 
      simp only [eq_self_iff_true, congr_arg_mpr_hom_right, eq_to_hom_refl, category.comp_id, dite_eq_ite, if_true, mem_singleton_iff] at hp ‚ä¢, 
      rw hp, apply inv_one, },
    { rw dif_neg (Œª l : c = d, h l.symm) at hp, exact hp.elim, }, }
, by 
  { rintros c d e p hp q hq,
    by_cases h : d = c,
    { by_cases k : e = d; subst_vars,
      { simp only [eq_self_iff_true, dite_eq_ite, if_true, mem_singleton_iff] at ‚ä¢ hp hq,
        rw [hp, hq], simp only [category.comp_id], }, 
      { simp only [eq_self_iff_true, dite_eq_ite, if_true, mem_singleton_iff] at ‚ä¢ hp hq,
        rw dif_neg (Œª l : d = e, k l.symm) at hq, exact hq.elim, }, },
    { rw dif_neg (Œª l : c = d, h l.symm) at hp, exact hp.elim, }
  }‚ü©





def is_normal (S : subgroupoid G) : Prop :=
  (‚àÄ c, (ùüô c) ‚àà (S.arrws c c)) ‚àß  -- S is "wide": all vertices of G are covered
  (‚àÄ {c d} (p : c ‚ü∂ d) (Œ≥ : c ‚ü∂ c) (hs : Œ≥ ‚àà S.arrws c c), ((G.inv p) ‚â´ Œ≥ ‚â´ p) ‚àà (S.arrws d d))

def is_normal.conjugation_eq (S : subgroupoid G) {c d} (p : c ‚ü∂ d) : function.bijective (Œª Œ≥ : c ‚ü∂ c, (G.inv p) ‚â´ Œ≥ ‚â´ p) := sorry  

lemma is_normal.Inf (s : set $ subgroupoid G) (sn : ‚àÄ S ‚àà s, is_normal S) : is_normal (Inf s) := 
begin
  split,
  { rintro c, dsimp only [Inf], rintro _ ‚ü®‚ü®S,Ss‚ü©,rfl‚ü©, exact (sn S Ss).left c,},
  { rintros c d p Œ≥ hŒ≥, dsimp only [Inf], rintro _ ‚ü®‚ü®S,Ss‚ü©,rfl‚ü©, apply (sn S Ss).right p Œ≥, apply hŒ≥, use ‚ü®S,Ss‚ü©,}
end 


/- Following Higgins -/
def is_strict_normal (S : subgroupoid G) : Prop := (is_normal S) ‚àß (‚àÄ (c d : C), c ‚â† d ‚Üí  (S.arrws c d) = ‚àÖ)



variable (X : ‚àÄ c d : C, set (G.hom c d))

-- Following Higgins, more or less
def generated : subgroupoid G := Inf { S : subgroupoid G | ‚àÄ (c d : C), X c d ‚äÜ S.arrws c d }

inductive word  (X : ‚àÄ c d : C, set (G.hom c d)) : C ‚Üí C ‚Üí Sort*
| nil {c : C} : word c c
| cons_p {c d e : C} (p : X c d) (w : word d e) : word c e
| cons_n {c d e : C} (p : X d c) (w : word d e) : word c e

variable {X}

def word.val  : Œ† {c d : C}, word X c d ‚Üí G.hom c d
| c .(c) (word.nil ) := (ùüô c)
| _ _ (word.cons_p p w) := p.val ‚â´ w.val  
| _ _ (word.cons_n p w) := (G.inv p.val) ‚â´ w.val

def word.letter {c d : C} (p : X c d) : word X c d := (word.cons_p p word.nil)

@[pattern]
def word.letter_p {c d : C} (p : X c d) : word X c d := word.letter p
@[pattern]
def word.letter_n {c d : C} (p : X c d) : word X d c := (word.cons_n p word.nil)

def word.append  : Œ† {c d e : C}, word X c d ‚Üí word X d e ‚Üí word X c e
| _ _ _ (word.nil) w := w
| _ _ _ (word.cons_p p u) w := word.cons_p p (u.append w)
| _ _ _ (word.cons_n p u) w := word.cons_n p (u.append w)

def word.reverse : Œ† {c d : C}, word X c d ‚Üí word X d c
| _ _ (word.nil) := word.nil
| _ _ (word.cons_p p u) := (u.reverse.append (word.letter_n p))
| _ _ (word.cons_n p u) := (u.reverse.append (word.letter_p p))

def word.nonempty  : Œ† {c d : C}, word X c d ‚Üí Prop
| _ _ (word.nil) := false
| _ _ _ := true

lemma word.nonempty_reverse  {c d : C} (p : word X c d) : p.nonempty ‚Üí p.reverse.nonempty := sorry
lemma word.nonempty_append  {c d e : C} (p : word X c d) (q : word X d e) :
  p.nonempty ‚à® q.nonempty ‚Üí (p.append q).nonempty := sorry

lemma word.letter_p_val {c d : C} (p : X c d) : (word.letter_p p).val = p.val := 
begin
  dsimp [word.letter_p,word.letter,word.val],
  simp only [category.comp_id],
end

lemma word.letter_n_val {c d : C} (p : X c d) : (word.letter_n p).val = G.inv p.val := 
begin
  dsimp [word.letter_n,word.val],
  simp only [category.comp_id],
end

lemma word.nonempty_letter_p {c d : C} (p : X c d) : (word.letter_p p).nonempty := trivial
lemma word.nonempty_letter_n {c d : C} (p : X c d) : (word.letter_n p).nonempty := trivial

lemma word.append_val {c d e : C} (u : word X c d) (w : word X d e) : 
  (u.append w).val = u.val ‚â´ w.val := sorry

lemma word.reverse_val {c d : C} (u : word X c d) : 
  (u.reverse).val = G.inv u.val := sorry

variable (X)
include X
def generated' : subgroupoid G :=  
begin
  fsplit,
  {rintros c d, apply set.image (Œª (p : word X c d), p.val ) {p : word X c d | p.nonempty},},
  {rintros c d _ ‚ü®u,un,rfl‚ü©, simp, use u.reverse, split, apply word.nonempty_reverse, apply un, apply word.reverse_val, },
  {rintros c d e _ ‚ü®u,un,rfl‚ü© _ ‚ü®w,wn,rfl‚ü©, simp, use u.append w, split, apply word.nonempty_append, use or.inl un, apply word.append_val, },
end

lemma generated'_contains : ‚àÄ (c d : C), X c d ‚äÜ (generated' X).arrws c d :=
begin
  rintros c d p pX,
  dsimp only [generated'],
  simp only [mem_image],
  let w : word X c d := word.letter_p ‚ü®p,pX‚ü©,
  use w, split, simp, exact word.letter_p_val ‚ü®p,pX‚ü©,
end

lemma contains_generated'  (S : subgroupoid G) (hS : ‚àÄ (c d : C), X c d ‚äÜ S.arrws c d) :
  Œ† {c d : C} (p : word X c d) (pn : p.nonempty), p.val ‚àà S.arrws c d
| _ _ (word.letter_p p) _ := by {rw word.letter_p_val,apply hS, exact p.prop,}
| _ _ (word.letter_n p) _ := by {rw word.letter_n_val,apply S.inv',apply hS, exact p.prop,}
| _ _ (word.cons_p p (word.cons_p q u)) _ := by 
{ apply S.mul',
  { apply hS, exact p.prop, },
  { apply contains_generated', trivial,} }
| _ _ (word.cons_p p (word.cons_n q u)) _ := by
{ apply S.mul',
  { apply hS, exact p.prop, },
  { apply contains_generated', trivial,} }
| _ _ (word.cons_n p (word.cons_p q u)) _ := by
{ apply S.mul',
  { apply S.inv', apply hS, exact p.prop, },
  { apply contains_generated', trivial,} }
| _ _ (word.cons_n p (word.cons_n q u)) _ := by 
{ apply S.mul',
  { apply S.inv', apply hS, exact p.prop, },
  { apply contains_generated', trivial,} }

lemma generated_eq' : generated X = generated' X := 
begin
  apply le_antisymm,
  { have : ‚àÄ (c d : C), X c d ‚äÜ (generated' X).arrws c d := generated'_contains X,
    exact @Inf_le _ _ { S : subgroupoid G | ‚àÄ (c d : C), X c d ‚äÜ S.arrws c d } (generated' X) this,},
  { have : ‚àÄ S : subgroupoid G, S ‚àà { S : subgroupoid G | ‚àÄ (c d : C), X c d ‚äÜ S.arrws c d} ‚Üí (generated' X) ‚â§ S, by
    { rintro S hS, rintro c d _ ‚ü®w,h,rfl‚ü©, simp only, apply contains_generated' X S hS w h,},
    apply @le_Inf _ _ { S : subgroupoid G | ‚àÄ (c d : C), X c d ‚äÜ S.arrws c d } (generated' X) this, }
end

def generated_on [decidable_eq C] (D : set C) : subgroupoid G := generated (Œª c d, (X c d) ‚à™ (if h : c = d then by { rw h, exact {ùüô d} } else ‚àÖ))


end subgroupoid


section strict_hom
/--
Higgins has his own version of normality and morphisms,  
where normality has a condition that all arrows between distinct vertices disappear, 
but I'm not sure this is the right way to look at it. 
We'll do it here, and try for a more general approach afterwards (where we don't have this added condition on normal subgroupoids, _and_ morphisms can play with vertices)
-/


variables {C} (G H : groupoid C) 



/- Following ‚ÄúPresentations of groupoids‚Äù by Higgins, p. 9, we call `strict_hom` the functors on underlying category being the identity on objects -/
structure strict_hom := 
( f   : Œ† {c d : C}, G.hom c d ‚Üí H.hom c d) 
( one : Œ† (c : C), f (ùüô c) = ùüô c )
( mul : Œ† {c d e : C} (p : G.hom c d) (q : G.hom d e), f (p ‚â´ q) = (f p) ‚â´ (f q ))
( inv : Œ† {c d : C} (p : G.hom c d), f (G.inv p) = (H.inv $ f p) )

infixr ` ‚Üí** `:25 := strict_hom

def strict_im (œÜ : G ‚Üí** H) : subgroupoid H := 
‚ü® Œª c d, {p : H.hom c d | ‚àÉ q : G.hom c d, p = œÜ.f q}
, by {rintros c d _ ‚ü®q,rfl‚ü©, rw ‚Üê œÜ.inv, simp only [mem_set_of_eq, exists_apply_eq_apply'],}
, by {rintros c d e _ ‚ü®p,rfl‚ü© _ ‚ü®q,rfl‚ü©, rw ‚Üê œÜ.mul, simp only [mem_set_of_eq, exists_apply_eq_apply'],}‚ü© 


variables {G H}

def strict_ker [decidable_eq C] (œÜ : G ‚Üí** H) : subgroupoid G := 
‚ü® Œª c d, if h : c = d then eq.rec_on h {f : c ‚ü∂ c | œÜ.f f = ùüô c} else ‚àÖ
, by 
  { rintros c d p hp, 
    by_cases h : d = c, 
    { subst_vars, rw dif_pos (eq.refl d) at hp ‚ä¢, simp at hp ‚ä¢, rw œÜ.inv, rw hp, exact inv_one, },
    { rw dif_neg (Œª l : c = d, h l.symm) at hp, finish, }}
, by 
  { rintros c d e p hp q hq, 
    by_cases h : d = c,
    { by_cases k : e = d,
      { subst_vars, rw dif_pos (eq.refl e) at hp hq ‚ä¢, simp at hp hq ‚ä¢, rw œÜ.mul, rw [hp,hq], exact mul_one (ùüô e),},
      { subst_vars, rw dif_neg (Œª l : d = e, k l.symm) at hq, finish,} },
    { rw dif_neg (Œª l : c = d, h l.symm) at hp, finish, }}
‚ü©


--lemma normal_iff [decidable_eq C] (S : subgroupoid G) : is_strict_normal G S ‚Üî ‚àÉ (H : groupoid C) (œÜ : G ‚Üí** H), S = strict_ker œÜ := sorry


end strict_hom


section hom

variables (C) (D : Type*)
variables [G : groupoid C] [H : groupoid D]
variable [decidable_eq D]

def hom := @category_theory.functor C G.to_category D H.to_category
local infix `‚•§i`:50 := hom

@[simp]
lemma functor.map_inv (œÜ : C ‚•§i D) {c d : C} (f : c ‚ü∂ d) :  
  œÜ.map (G.inv f) = H.inv (œÜ.map f) := 
calc œÜ.map (G.inv f) = (œÜ.map $ G.inv f) ‚â´ (ùüô $ œÜ.obj c) : by rw [category.comp_id]
                 ... = (œÜ.map $ G.inv f) ‚â´ ((œÜ.map f) ‚â´ (H.inv $ œÜ.map f)) : by rw [comp_inv]
                 ... = ((œÜ.map $ G.inv f) ‚â´ (œÜ.map f)) ‚â´ (H.inv $ œÜ.map f) : by rw [category.assoc]
                 ... = (œÜ.map $ G.inv f ‚â´ f) ‚â´ (H.inv $ œÜ.map f) : by rw [functor.map_comp']
                 ... = (H.inv $ œÜ.map f) : by rw [inv_comp,functor.map_id,category.id_comp]            



def subgroupoid.comap (œÜ : C ‚•§i D) (S : subgroupoid H) : subgroupoid G :=
‚ü® Œª c d, {f : c ‚ü∂ d | œÜ.map f ‚àà S.arrws (œÜ.obj c) (œÜ.obj d)}
, by 
  { rintros, simp only [mem_set_of_eq], rw functor.map_inv, apply S.inv', assumption, }
, by
  { rintros, simp only [mem_set_of_eq, functor.map_comp], apply S.mul'; assumption, }‚ü©

lemma is_normal.preimage [G: groupoid C] (œÜ : C ‚•§i D) {S : subgroupoid H} (Sn : is_normal S) : is_normal (subgroupoid.comap C D œÜ S) :=
begin
  dsimp only [is_normal,subgroupoid.comap,is_normal],
  split,
  { rintro c, simp only [mem_set_of_eq, functor.map_id], apply Sn.left, },
  { rintros c d f Œ≥ hŒ≥, simp only [mem_set_of_eq, functor.map_comp, functor.map_inv], apply Sn.right, exact hŒ≥, },
end

def ker [G : groupoid C] [H : groupoid D] (œÜ : C ‚•§i D) : subgroupoid G := subgroupoid.comap C D œÜ (discrete) 

def mem_ker_iff  [G : groupoid C] [H : groupoid D] (œÜ : C ‚•§i D) {c d : C} (f : c ‚ü∂ d) : 
  f ‚àà (ker C D œÜ).arrws c d ‚Üî ‚àÉ (h : œÜ.obj c = œÜ.obj d), œÜ.map f = h.rec_on (ùüô $ œÜ.obj c) :=
begin
  dsimp only [ker, discrete,subgroupoid.comap], 
  by_cases h : œÜ.obj c = œÜ.obj d,
  { simp only [dif_pos h, mem_singleton_iff, mem_set_of_eq], 
    split,
    { rintro e, use h, exact e, },
    { rintro ‚ü®_,e‚ü©, exact e, }},
  { simp only [dif_neg h, mem_empty_eq, set_of_false, false_iff, not_exists], 
    rintro e, exact (h e).elim, },
end

end hom


section quotient

--def quotient_vertex  [G : groupoid C] (S : subgroupoid G) (Sn : is_normal S) : Type* :=

--def quotient [G : groupoid C] (S : subgroupoid G) (Sn : is_normal S) := groupoid (category_theory.quiver.weakly_connected_component C )

end quotient


end groupoid
end category_theory